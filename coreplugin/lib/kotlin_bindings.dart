// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.daylightcomputer.coreplugin.entity.AttributeValueRecord`
class AttributeValueRecord extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AttributeValueRecord> $type;

  @jni$_.internal
  AttributeValueRecord.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/AttributeValueRecord');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AttributeValueRecord$NullableType();
  static const type = $AttributeValueRecord$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributeValueRecord(
    jni$_.JString? string,
    jni$_.JString string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1.reference;
    return AttributeValueRecord.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$string1.pointer)
        .reference);
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/String;',
  );

  static final _getValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getValue()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getValue() {
    return _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/String;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/String;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/String;Ljava/lang/String;)Lcom/daylightcomputer/coreplugin/entity/AttributeValueRecord;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.AttributeValueRecord copy(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributeValueRecord copy(
    jni$_.JString? string,
    jni$_.JString string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1.reference;
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<AttributeValueRecord>(const $AttributeValueRecord$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }
}

final class $AttributeValueRecord$NullableType
    extends jni$_.JObjType<AttributeValueRecord?> {
  @jni$_.internal
  const $AttributeValueRecord$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/AttributeValueRecord;';

  @jni$_.internal
  @core$_.override
  AttributeValueRecord? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AttributeValueRecord.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributeValueRecord?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributeValueRecord$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AttributeValueRecord$NullableType) &&
        other is $AttributeValueRecord$NullableType;
  }
}

final class $AttributeValueRecord$Type
    extends jni$_.JObjType<AttributeValueRecord> {
  @jni$_.internal
  const $AttributeValueRecord$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/AttributeValueRecord;';

  @jni$_.internal
  @core$_.override
  AttributeValueRecord fromReference(jni$_.JReference reference) =>
      AttributeValueRecord.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributeValueRecord?> get nullableType =>
      const $AttributeValueRecord$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributeValueRecord$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AttributeValueRecord$Type) &&
        other is $AttributeValueRecord$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.Entity$Companion`
class Entity$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Entity$Companion> $type;

  @jni$_.internal
  Entity$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/Entity$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Entity$Companion$NullableType();
  static const type = $Entity$Companion$Type();
  static final _id_fromAttributePool = _class.instanceMethodId(
    r'fromAttributePool',
    r'(Ljava/lang/String;Ljava/util/List;Lcom/daylightcomputer/coreplugin/entity/TimestampProvider;)Lcom/daylightcomputer/coreplugin/entity/Entity;',
  );

  static final _fromAttributePool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.Entity fromAttributePool(java.lang.String string, java.util.List list, com.daylightcomputer.coreplugin.entity.TimestampProvider timestampProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  Entity fromAttributePool(
    jni$_.JString string,
    jni$_.JList<jni$_.JObject> list,
    TimestampProvider timestampProvider,
  ) {
    final _$string = string.reference;
    final _$list = list.reference;
    final _$timestampProvider = timestampProvider.reference;
    return _fromAttributePool(
            reference.pointer,
            _id_fromAttributePool as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$list.pointer,
            _$timestampProvider.pointer)
        .object<Entity>(const $Entity$Type());
  }

  static final _id_allFromAttributePool = _class.instanceMethodId(
    r'allFromAttributePool',
    r'(Ljava/util/List;Lcom/daylightcomputer/coreplugin/entity/TimestampProvider;)Lkotlin/sequences/Sequence;',
  );

  static final _allFromAttributePool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.sequences.Sequence allFromAttributePool(java.util.List list, com.daylightcomputer.coreplugin.entity.TimestampProvider timestampProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject allFromAttributePool(
    jni$_.JList<jni$_.JObject> list,
    TimestampProvider timestampProvider,
  ) {
    final _$list = list.reference;
    final _$timestampProvider = timestampProvider.reference;
    return _allFromAttributePool(
            reference.pointer,
            _id_allFromAttributePool as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$timestampProvider.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Entity$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return Entity$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $Entity$Companion$NullableType
    extends jni$_.JObjType<Entity$Companion?> {
  @jni$_.internal
  const $Entity$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/Entity$Companion;';

  @jni$_.internal
  @core$_.override
  Entity$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Entity$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$Companion$NullableType) &&
        other is $Entity$Companion$NullableType;
  }
}

final class $Entity$Companion$Type extends jni$_.JObjType<Entity$Companion> {
  @jni$_.internal
  const $Entity$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/Entity$Companion;';

  @jni$_.internal
  @core$_.override
  Entity$Companion fromReference(jni$_.JReference reference) =>
      Entity$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity$Companion?> get nullableType =>
      const $Entity$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$Companion$Type) &&
        other is $Entity$Companion$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.Entity`
class Entity extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Entity> $type;

  @jni$_.internal
  Entity.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/daylightcomputer/coreplugin/entity/Entity');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Entity$NullableType();
  static const type = $Entity$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/daylightcomputer/coreplugin/entity/Entity$Companion;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.Entity$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static Entity$Companion get Companion =>
      _id_Companion.get(_class, const $Entity$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/util/Map;Lcom/daylightcomputer/coreplugin/entity/TimestampProvider;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.util.Map map, com.daylightcomputer.coreplugin.entity.TimestampProvider timestampProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Entity(
    jni$_.JString string,
    jni$_.JMap<jni$_.JString, AttributeValueRecord> map,
    TimestampProvider timestampProvider,
  ) {
    final _$string = string.reference;
    final _$map = map.reference;
    final _$timestampProvider = timestampProvider.reference;
    return Entity.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$map.pointer,
            _$timestampProvider.pointer)
        .reference);
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAttributes = _class.instanceMethodId(
    r'getAttributes',
    r'()Ljava/util/Map;',
  );

  static final _getAttributes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map getAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, AttributeValueRecord> getAttributes() {
    return _getAttributes(
            reference.pointer, _id_getAttributes as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, AttributeValueRecord>>(
            const jni$_.JMapType<jni$_.JString, AttributeValueRecord>(
                jni$_.JStringType(), $AttributeValueRecord$Type()));
  }

  static final _id_getAttributesList = _class.instanceMethodId(
    r'getAttributesList',
    r'()Ljava/util/List;',
  );

  static final _getAttributesList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List getAttributesList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> getAttributesList() {
    return _getAttributesList(
            reference.pointer, _id_getAttributesList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_getAttributeChanges = _class.instanceMethodId(
    r'getAttributeChanges',
    r'()Lkotlinx/coroutines/flow/SharedFlow;',
  );

  static final _getAttributeChanges = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final kotlinx.coroutines.flow.SharedFlow getAttributeChanges()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getAttributeChanges() {
    return _getAttributeChanges(
            reference.pointer, _id_getAttributeChanges as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_required = _class.instanceMethodId(
    r'required',
    r'(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lkotlin/properties/ReadOnlyProperty;',
  );

  static final _required = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.properties.ReadOnlyProperty required(java.lang.String string, kotlin.jvm.functions.Function1 function1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject required<$T extends jni$_.JObject?>(
    jni$_.JString string,
    jni$_.JObject function1, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    final _$function1 = function1.reference;
    return _required(reference.pointer, _id_required as jni$_.JMethodIDPtr,
            _$string.pointer, _$function1.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_requiredMutable = _class.instanceMethodId(
    r'requiredMutable',
    r'(Ljava/lang/String;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Lkotlin/properties/ReadWriteProperty;',
  );

  static final _requiredMutable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.properties.ReadWriteProperty requiredMutable(java.lang.String string, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject requiredMutable<$T extends jni$_.JObject?>(
    jni$_.JString string,
    jni$_.JObject function1,
    jni$_.JObject function11, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    final _$function1 = function1.reference;
    final _$function11 = function11.reference;
    return _requiredMutable(
            reference.pointer,
            _id_requiredMutable as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$function1.pointer,
            _$function11.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_optional = _class.instanceMethodId(
    r'optional',
    r'(Ljava/lang/String;Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Lkotlin/properties/ReadOnlyProperty;',
  );

  static final _optional = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.properties.ReadOnlyProperty optional(java.lang.String string, T object, kotlin.jvm.functions.Function1 function1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject optional<$T extends jni$_.JObject?>(
    jni$_.JString string,
    $T object,
    jni$_.JObject function1, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$function1 = function1.reference;
    return _optional(reference.pointer, _id_optional as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer, _$function1.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_optionalMutable = _class.instanceMethodId(
    r'optionalMutable',
    r'(Ljava/lang/String;Ljava/lang/Object;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Lkotlin/properties/ReadWriteProperty;',
  );

  static final _optionalMutable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.properties.ReadWriteProperty optionalMutable(java.lang.String string, T object, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject optionalMutable<$T extends jni$_.JObject?>(
    jni$_.JString string,
    $T object,
    jni$_.JObject function1,
    jni$_.JObject function11, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$function1 = function1.reference;
    final _$function11 = function11.reference;
    return _optionalMutable(
            reference.pointer,
            _id_optionalMutable as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$object.pointer,
            _$function1.pointer,
            _$function11.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_derived = _class.instanceMethodId(
    r'derived',
    r'(Lkotlin/jvm/functions/Function1;)Lkotlin/properties/ReadOnlyProperty;',
  );

  static final _derived = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.properties.ReadOnlyProperty derived(kotlin.jvm.functions.Function1 function1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject derived<$T extends jni$_.JObject?>(
    jni$_.JObject function1, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$function1 = function1.reference;
    return _derived(reference.pointer, _id_derived as jni$_.JMethodIDPtr,
            _$function1.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getRequiredAttribute = _class.instanceMethodId(
    r'getRequiredAttribute',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getRequiredAttribute = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.lang.String getRequiredAttribute(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRequiredAttribute(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getRequiredAttribute(reference.pointer,
            _id_getRequiredAttribute as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAttribute = _class.instanceMethodId(
    r'getAttribute',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getAttribute = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.lang.String getAttribute(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAttribute(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getAttribute(reference.pointer,
            _id_getAttribute as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setAttribute = _class.instanceMethodId(
    r'setAttribute',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setAttribute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setAttribute(java.lang.String string, java.lang.String string1)`
  void setAttribute(
    jni$_.JString string,
    jni$_.JString? string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setAttribute(reference.pointer, _id_setAttribute as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $Entity$NullableType extends jni$_.JObjType<Entity?> {
  @jni$_.internal
  const $Entity$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/daylightcomputer/coreplugin/entity/Entity;';

  @jni$_.internal
  @core$_.override
  Entity? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Entity.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$NullableType) &&
        other is $Entity$NullableType;
  }
}

final class $Entity$Type extends jni$_.JObjType<Entity> {
  @jni$_.internal
  const $Entity$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/daylightcomputer/coreplugin/entity/Entity;';

  @jni$_.internal
  @core$_.override
  Entity fromReference(jni$_.JReference reference) => Entity.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity?> get nullableType => const $Entity$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$Type) && other is $Entity$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.TimestampProvider`
class TimestampProvider extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<TimestampProvider> $type;

  @jni$_.internal
  TimestampProvider.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/TimestampProvider');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $TimestampProvider$NullableType();
  static const type = $TimestampProvider$Type();
  static final _id_issueTimestamp = _class.instanceMethodId(
    r'issueTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _issueTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String issueTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString issueTimestamp() {
    return _issueTimestamp(
            reference.pointer, _id_issueTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $TimestampProvider> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'issueTimestamp()Ljava/lang/String;') {
        final $r = _$impls[$p]!.issueTimestamp();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $TimestampProvider $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.daylightcomputer.coreplugin.entity.TimestampProvider',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory TimestampProvider.implement(
    $TimestampProvider $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return TimestampProvider.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $TimestampProvider {
  factory $TimestampProvider({
    required jni$_.JString Function() issueTimestamp,
  }) = _$TimestampProvider;

  jni$_.JString issueTimestamp();
}

final class _$TimestampProvider with $TimestampProvider {
  _$TimestampProvider({
    required jni$_.JString Function() issueTimestamp,
  }) : _issueTimestamp = issueTimestamp;

  final jni$_.JString Function() _issueTimestamp;

  jni$_.JString issueTimestamp() {
    return _issueTimestamp();
  }
}

final class $TimestampProvider$NullableType
    extends jni$_.JObjType<TimestampProvider?> {
  @jni$_.internal
  const $TimestampProvider$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/TimestampProvider;';

  @jni$_.internal
  @core$_.override
  TimestampProvider? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : TimestampProvider.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TimestampProvider?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TimestampProvider$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimestampProvider$NullableType) &&
        other is $TimestampProvider$NullableType;
  }
}

final class $TimestampProvider$Type extends jni$_.JObjType<TimestampProvider> {
  @jni$_.internal
  const $TimestampProvider$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/TimestampProvider;';

  @jni$_.internal
  @core$_.override
  TimestampProvider fromReference(jni$_.JReference reference) =>
      TimestampProvider.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TimestampProvider?> get nullableType =>
      const $TimestampProvider$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TimestampProvider$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimestampProvider$Type) &&
        other is $TimestampProvider$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.DocumentNode`
class DocumentNode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DocumentNode> $type;

  @jni$_.internal
  DocumentNode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/DocumentNode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DocumentNode$NullableType();
  static const type = $DocumentNode$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DocumentNode(
    Entity entity,
  ) {
    final _$entity = entity.reference;
    return DocumentNode.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$entity.pointer)
        .reference);
  }

  static final _id_getChangeNotifications = _class.instanceMethodId(
    r'getChangeNotifications',
    r'()Lkotlinx/coroutines/flow/Flow;',
  );

  static final _getChangeNotifications = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public kotlinx.coroutines.flow.Flow getChangeNotifications()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications(
            reference.pointer, _id_getChangeNotifications as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_isDeleted = _class.instanceMethodId(
    r'isDeleted',
    r'()Z',
  );

  static final _isDeleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDeleted()`
  bool isDeleted() {
    return _isDeleted(reference.pointer, _id_isDeleted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getLastModifiedAtTimestamp = _class.instanceMethodId(
    r'getLastModifiedAtTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getLastModifiedAtTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.String getLastModifiedAtTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp(reference.pointer,
            _id_getLastModifiedAtTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTitle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.daylightcomputer.coreplugin.entity.thing.ThingTypes getType()`
  /// The returned object must be released after use, by calling the [release] method.
  ThingTypes getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<ThingTypes>(const $ThingTypes$Type());
  }

  static final _id_getAuthor = _class.instanceMethodId(
    r'getAuthor',
    r'()Ljava/lang/String;',
  );

  static final _getAuthor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAuthor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAuthor() {
    return _getAuthor(reference.pointer, _id_getAuthor as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getThought = _class.instanceMethodId(
    r'getThought',
    r'()Ljava/lang/String;',
  );

  static final _getThought = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getThought()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getThought() {
    return _getThought(reference.pointer, _id_getThought as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setThought = _class.instanceMethodId(
    r'setThought',
    r'(Ljava/lang/String;)V',
  );

  static final _setThought = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setThought(java.lang.String string)`
  void setThought(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setThought(reference.pointer, _id_setThought as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getComment = _class.instanceMethodId(
    r'getComment',
    r'()Ljava/lang/String;',
  );

  static final _getComment = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getComment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getComment() {
    return _getComment(reference.pointer, _id_getComment as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setComment = _class.instanceMethodId(
    r'setComment',
    r'(Ljava/lang/String;)V',
  );

  static final _setComment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setComment(java.lang.String string)`
  void setComment(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setComment(reference.pointer, _id_setComment as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_validatePropertiesOnInit = _class.instanceMethodId(
    r'validatePropertiesOnInit',
    r'()V',
  );

  static final _validatePropertiesOnInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void validatePropertiesOnInit()`
  void validatePropertiesOnInit() {
    _validatePropertiesOnInit(reference.pointer,
            _id_validatePropertiesOnInit as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $DocumentNode$NullableType extends jni$_.JObjType<DocumentNode?> {
  @jni$_.internal
  const $DocumentNode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/DocumentNode;';

  @jni$_.internal
  @core$_.override
  DocumentNode? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : DocumentNode.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DocumentNode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DocumentNode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DocumentNode$NullableType) &&
        other is $DocumentNode$NullableType;
  }
}

final class $DocumentNode$Type extends jni$_.JObjType<DocumentNode> {
  @jni$_.internal
  const $DocumentNode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/DocumentNode;';

  @jni$_.internal
  @core$_.override
  DocumentNode fromReference(jni$_.JReference reference) =>
      DocumentNode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DocumentNode?> get nullableType =>
      const $DocumentNode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DocumentNode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DocumentNode$Type) &&
        other is $DocumentNode$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.IDocumentNode`
class IDocumentNode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IDocumentNode> $type;

  @jni$_.internal
  IDocumentNode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/IDocumentNode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IDocumentNode$NullableType();
  static const type = $IDocumentNode$Type();
  static final _id_getAuthor = _class.instanceMethodId(
    r'getAuthor',
    r'()Ljava/lang/String;',
  );

  static final _getAuthor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getAuthor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAuthor() {
    return _getAuthor(reference.pointer, _id_getAuthor as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getThought = _class.instanceMethodId(
    r'getThought',
    r'()Ljava/lang/String;',
  );

  static final _getThought = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getThought()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getThought() {
    return _getThought(reference.pointer, _id_getThought as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setThought = _class.instanceMethodId(
    r'setThought',
    r'(Ljava/lang/String;)V',
  );

  static final _setThought = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void setThought(java.lang.String string)`
  void setThought(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setThought(reference.pointer, _id_setThought as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getComment = _class.instanceMethodId(
    r'getComment',
    r'()Ljava/lang/String;',
  );

  static final _getComment = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getComment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getComment() {
    return _getComment(reference.pointer, _id_getComment as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setComment = _class.instanceMethodId(
    r'setComment',
    r'(Ljava/lang/String;)V',
  );

  static final _setComment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void setComment(java.lang.String string)`
  void setComment(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setComment(reference.pointer, _id_setComment as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $IDocumentNode> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getAuthor()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getAuthor();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getThought()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getThought();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'setThought(Ljava/lang/String;)V') {
        _$impls[$p]!.setThought(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'getComment()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getComment();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'setComment(Ljava/lang/String;)V') {
        _$impls[$p]!.setComment(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $IDocumentNode $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.daylightcomputer.coreplugin.entity.thing.IDocumentNode',
      $p,
      _$invokePointer,
      [
        if ($impl.setThought$async) r'setThought(Ljava/lang/String;)V',
        if ($impl.setComment$async) r'setComment(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory IDocumentNode.implement(
    $IDocumentNode $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return IDocumentNode.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $IDocumentNode {
  factory $IDocumentNode({
    required jni$_.JString? Function() getAuthor,
    required jni$_.JString? Function() getThought,
    required void Function(jni$_.JString? string) setThought,
    bool setThought$async,
    required jni$_.JString? Function() getComment,
    required void Function(jni$_.JString? string) setComment,
    bool setComment$async,
  }) = _$IDocumentNode;

  jni$_.JString? getAuthor();
  jni$_.JString? getThought();
  void setThought(jni$_.JString? string);
  bool get setThought$async => false;
  jni$_.JString? getComment();
  void setComment(jni$_.JString? string);
  bool get setComment$async => false;
}

final class _$IDocumentNode with $IDocumentNode {
  _$IDocumentNode({
    required jni$_.JString? Function() getAuthor,
    required jni$_.JString? Function() getThought,
    required void Function(jni$_.JString? string) setThought,
    this.setThought$async = false,
    required jni$_.JString? Function() getComment,
    required void Function(jni$_.JString? string) setComment,
    this.setComment$async = false,
  })  : _getAuthor = getAuthor,
        _getThought = getThought,
        _setThought = setThought,
        _getComment = getComment,
        _setComment = setComment;

  final jni$_.JString? Function() _getAuthor;
  final jni$_.JString? Function() _getThought;
  final void Function(jni$_.JString? string) _setThought;
  final bool setThought$async;
  final jni$_.JString? Function() _getComment;
  final void Function(jni$_.JString? string) _setComment;
  final bool setComment$async;

  jni$_.JString? getAuthor() {
    return _getAuthor();
  }

  jni$_.JString? getThought() {
    return _getThought();
  }

  void setThought(jni$_.JString? string) {
    return _setThought(string);
  }

  jni$_.JString? getComment() {
    return _getComment();
  }

  void setComment(jni$_.JString? string) {
    return _setComment(string);
  }
}

final class $IDocumentNode$NullableType extends jni$_.JObjType<IDocumentNode?> {
  @jni$_.internal
  const $IDocumentNode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/IDocumentNode;';

  @jni$_.internal
  @core$_.override
  IDocumentNode? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : IDocumentNode.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IDocumentNode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IDocumentNode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IDocumentNode$NullableType) &&
        other is $IDocumentNode$NullableType;
  }
}

final class $IDocumentNode$Type extends jni$_.JObjType<IDocumentNode> {
  @jni$_.internal
  const $IDocumentNode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/IDocumentNode;';

  @jni$_.internal
  @core$_.override
  IDocumentNode fromReference(jni$_.JReference reference) =>
      IDocumentNode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IDocumentNode?> get nullableType =>
      const $IDocumentNode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IDocumentNode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IDocumentNode$Type) &&
        other is $IDocumentNode$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.INode`
class INode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<INode> $type;

  @jni$_.internal
  INode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/INode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $INode$NullableType();
  static const type = $INode$Type();
  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getTitle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.daylightcomputer.coreplugin.entity.thing.ThingTypes getType()`
  /// The returned object must be released after use, by calling the [release] method.
  ThingTypes getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<ThingTypes>(const $ThingTypes$Type());
  }

  static final _id_isDeleted = _class.instanceMethodId(
    r'isDeleted',
    r'()Z',
  );

  static final _isDeleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isDeleted()`
  bool isDeleted() {
    return _isDeleted(reference.pointer, _id_isDeleted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getLastModifiedAtTimestamp = _class.instanceMethodId(
    r'getLastModifiedAtTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getLastModifiedAtTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract java.lang.String getLastModifiedAtTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp(reference.pointer,
            _id_getLastModifiedAtTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getChangeNotifications = _class.instanceMethodId(
    r'getChangeNotifications',
    r'()Lkotlinx/coroutines/flow/Flow;',
  );

  static final _getChangeNotifications = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract kotlinx.coroutines.flow.Flow getChangeNotifications()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications(
            reference.pointer, _id_getChangeNotifications as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_validatePropertiesOnInit = _class.instanceMethodId(
    r'validatePropertiesOnInit',
    r'()V',
  );

  static final _validatePropertiesOnInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void validatePropertiesOnInit()`
  void validatePropertiesOnInit() {
    _validatePropertiesOnInit(reference.pointer,
            _id_validatePropertiesOnInit as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $INode> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getTitle()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getTitle();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getId()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getId();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getType()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;') {
        final $r = _$impls[$p]!.getType();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'isDeleted()Z') {
        final $r = _$impls[$p]!.isDeleted();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'getLastModifiedAtTimestamp()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getLastModifiedAtTimestamp();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getChangeNotifications()Lkotlinx/coroutines/flow/Flow;') {
        final $r = _$impls[$p]!.getChangeNotifications();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'validatePropertiesOnInit()V') {
        _$impls[$p]!.validatePropertiesOnInit();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $INode $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.daylightcomputer.coreplugin.entity.thing.INode',
      $p,
      _$invokePointer,
      [
        if ($impl.validatePropertiesOnInit$async)
          r'validatePropertiesOnInit()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory INode.implement(
    $INode $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return INode.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $INode {
  factory $INode({
    required jni$_.JString Function() getTitle,
    required jni$_.JString Function() getId,
    required ThingTypes Function() getType,
    required bool Function() isDeleted,
    required jni$_.JString Function() getLastModifiedAtTimestamp,
    required jni$_.JObject Function() getChangeNotifications,
    required void Function() validatePropertiesOnInit,
    bool validatePropertiesOnInit$async,
  }) = _$INode;

  jni$_.JString getTitle();
  jni$_.JString getId();
  ThingTypes getType();
  bool isDeleted();
  jni$_.JString getLastModifiedAtTimestamp();
  jni$_.JObject getChangeNotifications();
  void validatePropertiesOnInit();
  bool get validatePropertiesOnInit$async => false;
}

final class _$INode with $INode {
  _$INode({
    required jni$_.JString Function() getTitle,
    required jni$_.JString Function() getId,
    required ThingTypes Function() getType,
    required bool Function() isDeleted,
    required jni$_.JString Function() getLastModifiedAtTimestamp,
    required jni$_.JObject Function() getChangeNotifications,
    required void Function() validatePropertiesOnInit,
    this.validatePropertiesOnInit$async = false,
  })  : _getTitle = getTitle,
        _getId = getId,
        _getType = getType,
        _isDeleted = isDeleted,
        _getLastModifiedAtTimestamp = getLastModifiedAtTimestamp,
        _getChangeNotifications = getChangeNotifications,
        _validatePropertiesOnInit = validatePropertiesOnInit;

  final jni$_.JString Function() _getTitle;
  final jni$_.JString Function() _getId;
  final ThingTypes Function() _getType;
  final bool Function() _isDeleted;
  final jni$_.JString Function() _getLastModifiedAtTimestamp;
  final jni$_.JObject Function() _getChangeNotifications;
  final void Function() _validatePropertiesOnInit;
  final bool validatePropertiesOnInit$async;

  jni$_.JString getTitle() {
    return _getTitle();
  }

  jni$_.JString getId() {
    return _getId();
  }

  ThingTypes getType() {
    return _getType();
  }

  bool isDeleted() {
    return _isDeleted();
  }

  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp();
  }

  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications();
  }

  void validatePropertiesOnInit() {
    return _validatePropertiesOnInit();
  }
}

final class $INode$NullableType extends jni$_.JObjType<INode?> {
  @jni$_.internal
  const $INode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/INode;';

  @jni$_.internal
  @core$_.override
  INode? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : INode.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<INode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($INode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($INode$NullableType) &&
        other is $INode$NullableType;
  }
}

final class $INode$Type extends jni$_.JObjType<INode> {
  @jni$_.internal
  const $INode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/INode;';

  @jni$_.internal
  @core$_.override
  INode fromReference(jni$_.JReference reference) => INode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<INode?> get nullableType => const $INode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($INode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($INode$Type) && other is $INode$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.IThing`
class IThing extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IThing> $type;

  @jni$_.internal
  IThing.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/IThing');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IThing$NullableType();
  static const type = $IThing$Type();
  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.daylightcomputer.coreplugin.entity.thing.ThingTypes getType()`
  /// The returned object must be released after use, by calling the [release] method.
  ThingTypes getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<ThingTypes>(const $ThingTypes$Type());
  }

  static final _id_isDeleted = _class.instanceMethodId(
    r'isDeleted',
    r'()Z',
  );

  static final _isDeleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isDeleted()`
  bool isDeleted() {
    return _isDeleted(reference.pointer, _id_isDeleted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getLastModifiedAtTimestamp = _class.instanceMethodId(
    r'getLastModifiedAtTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getLastModifiedAtTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract java.lang.String getLastModifiedAtTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp(reference.pointer,
            _id_getLastModifiedAtTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getChangeNotifications = _class.instanceMethodId(
    r'getChangeNotifications',
    r'()Lkotlinx/coroutines/flow/Flow;',
  );

  static final _getChangeNotifications = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract kotlinx.coroutines.flow.Flow getChangeNotifications()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications(
            reference.pointer, _id_getChangeNotifications as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_validatePropertiesOnInit = _class.instanceMethodId(
    r'validatePropertiesOnInit',
    r'()V',
  );

  static final _validatePropertiesOnInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void validatePropertiesOnInit()`
  void validatePropertiesOnInit() {
    _validatePropertiesOnInit(reference.pointer,
            _id_validatePropertiesOnInit as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $IThing> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getId()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getId();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getType()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;') {
        final $r = _$impls[$p]!.getType();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'isDeleted()Z') {
        final $r = _$impls[$p]!.isDeleted();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'getLastModifiedAtTimestamp()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getLastModifiedAtTimestamp();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getChangeNotifications()Lkotlinx/coroutines/flow/Flow;') {
        final $r = _$impls[$p]!.getChangeNotifications();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'validatePropertiesOnInit()V') {
        _$impls[$p]!.validatePropertiesOnInit();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $IThing $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.daylightcomputer.coreplugin.entity.thing.IThing',
      $p,
      _$invokePointer,
      [
        if ($impl.validatePropertiesOnInit$async)
          r'validatePropertiesOnInit()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory IThing.implement(
    $IThing $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return IThing.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $IThing {
  factory $IThing({
    required jni$_.JString Function() getId,
    required ThingTypes Function() getType,
    required bool Function() isDeleted,
    required jni$_.JString Function() getLastModifiedAtTimestamp,
    required jni$_.JObject Function() getChangeNotifications,
    required void Function() validatePropertiesOnInit,
    bool validatePropertiesOnInit$async,
  }) = _$IThing;

  jni$_.JString getId();
  ThingTypes getType();
  bool isDeleted();
  jni$_.JString getLastModifiedAtTimestamp();
  jni$_.JObject getChangeNotifications();
  void validatePropertiesOnInit();
  bool get validatePropertiesOnInit$async => false;
}

final class _$IThing with $IThing {
  _$IThing({
    required jni$_.JString Function() getId,
    required ThingTypes Function() getType,
    required bool Function() isDeleted,
    required jni$_.JString Function() getLastModifiedAtTimestamp,
    required jni$_.JObject Function() getChangeNotifications,
    required void Function() validatePropertiesOnInit,
    this.validatePropertiesOnInit$async = false,
  })  : _getId = getId,
        _getType = getType,
        _isDeleted = isDeleted,
        _getLastModifiedAtTimestamp = getLastModifiedAtTimestamp,
        _getChangeNotifications = getChangeNotifications,
        _validatePropertiesOnInit = validatePropertiesOnInit;

  final jni$_.JString Function() _getId;
  final ThingTypes Function() _getType;
  final bool Function() _isDeleted;
  final jni$_.JString Function() _getLastModifiedAtTimestamp;
  final jni$_.JObject Function() _getChangeNotifications;
  final void Function() _validatePropertiesOnInit;
  final bool validatePropertiesOnInit$async;

  jni$_.JString getId() {
    return _getId();
  }

  ThingTypes getType() {
    return _getType();
  }

  bool isDeleted() {
    return _isDeleted();
  }

  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp();
  }

  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications();
  }

  void validatePropertiesOnInit() {
    return _validatePropertiesOnInit();
  }
}

final class $IThing$NullableType extends jni$_.JObjType<IThing?> {
  @jni$_.internal
  const $IThing$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/IThing;';

  @jni$_.internal
  @core$_.override
  IThing? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : IThing.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IThing?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IThing$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IThing$NullableType) &&
        other is $IThing$NullableType;
  }
}

final class $IThing$Type extends jni$_.JObjType<IThing> {
  @jni$_.internal
  const $IThing$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/IThing;';

  @jni$_.internal
  @core$_.override
  IThing fromReference(jni$_.JReference reference) => IThing.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IThing?> get nullableType => const $IThing$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IThing$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IThing$Type) && other is $IThing$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.Node`
class Node extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Node> $type;

  @jni$_.internal
  Node.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/Node');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Node$NullableType();
  static const type = $Node$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Node(
    Entity entity,
  ) {
    final _$entity = entity.reference;
    return Node.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$entity.pointer)
        .reference);
  }

  static final _id_getChangeNotifications = _class.instanceMethodId(
    r'getChangeNotifications',
    r'()Lkotlinx/coroutines/flow/Flow;',
  );

  static final _getChangeNotifications = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public kotlinx.coroutines.flow.Flow getChangeNotifications()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications(
            reference.pointer, _id_getChangeNotifications as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_isDeleted = _class.instanceMethodId(
    r'isDeleted',
    r'()Z',
  );

  static final _isDeleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDeleted()`
  bool isDeleted() {
    return _isDeleted(reference.pointer, _id_isDeleted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getLastModifiedAtTimestamp = _class.instanceMethodId(
    r'getLastModifiedAtTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getLastModifiedAtTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.String getLastModifiedAtTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp(reference.pointer,
            _id_getLastModifiedAtTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.daylightcomputer.coreplugin.entity.thing.ThingTypes getType()`
  /// The returned object must be released after use, by calling the [release] method.
  ThingTypes getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<ThingTypes>(const $ThingTypes$Type());
  }

  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTitle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_validatePropertiesOnInit = _class.instanceMethodId(
    r'validatePropertiesOnInit',
    r'()V',
  );

  static final _validatePropertiesOnInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void validatePropertiesOnInit()`
  void validatePropertiesOnInit() {
    _validatePropertiesOnInit(reference.pointer,
            _id_validatePropertiesOnInit as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $Node$NullableType extends jni$_.JObjType<Node?> {
  @jni$_.internal
  const $Node$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/Node;';

  @jni$_.internal
  @core$_.override
  Node? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Node.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Node?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Node$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Node$NullableType) &&
        other is $Node$NullableType;
  }
}

final class $Node$Type extends jni$_.JObjType<Node> {
  @jni$_.internal
  const $Node$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/Node;';

  @jni$_.internal
  @core$_.override
  Node fromReference(jni$_.JReference reference) => Node.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Node?> get nullableType => const $Node$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Node$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Node$Type) && other is $Node$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.Thing`
class Thing extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Thing> $type;

  @jni$_.internal
  Thing.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/Thing');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Thing$NullableType();
  static const type = $Thing$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Thing(
    Entity entity,
  ) {
    final _$entity = entity.reference;
    return Thing.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$entity.pointer)
        .reference);
  }

  static final _id_getEntity = _class.instanceMethodId(
    r'getEntity',
    r'()Lcom/daylightcomputer/coreplugin/entity/Entity;',
  );

  static final _getEntity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.Entity getEntity()`
  /// The returned object must be released after use, by calling the [release] method.
  Entity getEntity() {
    return _getEntity(reference.pointer, _id_getEntity as jni$_.JMethodIDPtr)
        .object<Entity>(const $Entity$Type());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.daylightcomputer.coreplugin.entity.thing.ThingTypes getType()`
  /// The returned object must be released after use, by calling the [release] method.
  ThingTypes getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<ThingTypes>(const $ThingTypes$Type());
  }

  static final _id_getLastModifiedAtTimestamp = _class.instanceMethodId(
    r'getLastModifiedAtTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getLastModifiedAtTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.String getLastModifiedAtTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp(reference.pointer,
            _id_getLastModifiedAtTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_validatePropertiesOnInit = _class.instanceMethodId(
    r'validatePropertiesOnInit',
    r'()V',
  );

  static final _validatePropertiesOnInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void validatePropertiesOnInit()`
  void validatePropertiesOnInit() {
    _validatePropertiesOnInit(reference.pointer,
            _id_validatePropertiesOnInit as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_isDeleted = _class.instanceMethodId(
    r'isDeleted',
    r'()Z',
  );

  static final _isDeleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDeleted()`
  bool isDeleted() {
    return _isDeleted(reference.pointer, _id_isDeleted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getChangeNotifications = _class.instanceMethodId(
    r'getChangeNotifications',
    r'()Lkotlinx/coroutines/flow/Flow;',
  );

  static final _getChangeNotifications = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public kotlinx.coroutines.flow.Flow getChangeNotifications()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getChangeNotifications() {
    return _getChangeNotifications(
            reference.pointer, _id_getChangeNotifications as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $Thing$NullableType extends jni$_.JObjType<Thing?> {
  @jni$_.internal
  const $Thing$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/Thing;';

  @jni$_.internal
  @core$_.override
  Thing? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Thing.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Thing?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Thing$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Thing$NullableType) &&
        other is $Thing$NullableType;
  }
}

final class $Thing$Type extends jni$_.JObjType<Thing> {
  @jni$_.internal
  const $Thing$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/Thing;';

  @jni$_.internal
  @core$_.override
  Thing fromReference(jni$_.JReference reference) => Thing.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Thing?> get nullableType => const $Thing$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Thing$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Thing$Type) && other is $Thing$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.ThingTypes$Companion`
class ThingTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ThingTypes$Companion> $type;

  @jni$_.internal
  ThingTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/ThingTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ThingTypes$Companion$NullableType();
  static const type = $ThingTypes$Companion$Type();
  static final _id_fromString = _class.instanceMethodId(
    r'fromString',
    r'(Ljava/lang/String;)Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _fromString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.thing.ThingTypes fromString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ThingTypes fromString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _fromString(reference.pointer, _id_fromString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<ThingTypes>(const $ThingTypes$Type());
  }

  static final _id_createNodeFromEntity = _class.instanceMethodId(
    r'createNodeFromEntity',
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)Lcom/daylightcomputer/coreplugin/entity/thing/Thing;',
  );

  static final _createNodeFromEntity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final T createNodeFromEntity(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? createNodeFromEntity<$T extends jni$_.JObject>(
    Entity entity, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$entity = entity.reference;
    return _createNodeFromEntity(reference.pointer,
            _id_createNodeFromEntity as jni$_.JMethodIDPtr, _$entity.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ThingTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ThingTypes$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $ThingTypes$Companion$NullableType
    extends jni$_.JObjType<ThingTypes$Companion?> {
  @jni$_.internal
  const $ThingTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes$Companion;';

  @jni$_.internal
  @core$_.override
  ThingTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ThingTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ThingTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ThingTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ThingTypes$Companion$NullableType) &&
        other is $ThingTypes$Companion$NullableType;
  }
}

final class $ThingTypes$Companion$Type
    extends jni$_.JObjType<ThingTypes$Companion> {
  @jni$_.internal
  const $ThingTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes$Companion;';

  @jni$_.internal
  @core$_.override
  ThingTypes$Companion fromReference(jni$_.JReference reference) =>
      ThingTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ThingTypes$Companion?> get nullableType =>
      const $ThingTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ThingTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ThingTypes$Companion$Type) &&
        other is $ThingTypes$Companion$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.thing.ThingTypes`
class ThingTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ThingTypes> $type;

  @jni$_.internal
  ThingTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/thing/ThingTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ThingTypes$NullableType();
  static const type = $ThingTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes$Companion;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.thing.ThingTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static ThingTypes$Companion get Companion =>
      _id_Companion.get(_class, const $ThingTypes$Companion$Type());

  static final _id_DOCUMENT_NODE = _class.staticFieldId(
    r'DOCUMENT_NODE',
    r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.thing.ThingTypes DOCUMENT_NODE`
  /// The returned object must be released after use, by calling the [release] method.
  static ThingTypes get DOCUMENT_NODE =>
      _id_DOCUMENT_NODE.get(_class, const $ThingTypes$Type());

  static final _id_NODE = _class.staticFieldId(
    r'NODE',
    r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.thing.ThingTypes NODE`
  /// The returned object must be released after use, by calling the [release] method.
  static ThingTypes get NODE => _id_NODE.get(_class, const $ThingTypes$Type());

  static final _id_BASE = _class.staticFieldId(
    r'BASE',
    r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.thing.ThingTypes BASE`
  /// The returned object must be released after use, by calling the [release] method.
  static ThingTypes get BASE => _id_BASE.get(_class, const $ThingTypes$Type());

  static final _id_getStringValue = _class.instanceMethodId(
    r'getStringValue',
    r'()Ljava/lang/String;',
  );

  static final _getStringValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getStringValue()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getStringValue() {
    return _getStringValue(
            reference.pointer, _id_getStringValue as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getFactory = _class.instanceMethodId(
    r'getFactory',
    r'()Lkotlin/jvm/functions/Function1;',
  );

  static final _getFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final kotlin.jvm.functions.Function1 getFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFactory() {
    return _getFactory(reference.pointer, _id_getFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.daylightcomputer.coreplugin.entity.thing.ThingTypes[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ThingTypes?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<ThingTypes?>?>(
            const jni$_.JArrayNullableType<ThingTypes?>(
                $ThingTypes$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.daylightcomputer.coreplugin.entity.thing.ThingTypes valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ThingTypes? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<ThingTypes?>(const $ThingTypes$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $ThingTypes$NullableType extends jni$_.JObjType<ThingTypes?> {
  @jni$_.internal
  const $ThingTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;';

  @jni$_.internal
  @core$_.override
  ThingTypes? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ThingTypes.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ThingTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ThingTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ThingTypes$NullableType) &&
        other is $ThingTypes$NullableType;
  }
}

final class $ThingTypes$Type extends jni$_.JObjType<ThingTypes> {
  @jni$_.internal
  const $ThingTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/thing/ThingTypes;';

  @jni$_.internal
  @core$_.override
  ThingTypes fromReference(jni$_.JReference reference) =>
      ThingTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ThingTypes?> get nullableType =>
      const $ThingTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ThingTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ThingTypes$Type) && other is $ThingTypes$Type;
  }
}
