// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.daylightcomputer.coreplugin.entity.AttributeValue`
class AttributeValue extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AttributeValue> $type;

  @jni$_.internal
  AttributeValue.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/AttributeValue');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AttributeValue$NullableType();
  static const type = $AttributeValue$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributeValue(
    jni$_.JString? string,
    jni$_.JString string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1.reference;
    return AttributeValue.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$string1.pointer)
        .reference);
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/String;',
  );

  static final _getValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getValue()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getValue() {
    return _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/String;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/String;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/String;Ljava/lang/String;)Lcom/daylightcomputer/coreplugin/entity/AttributeValue;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.AttributeValue copy(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributeValue copy(
    jni$_.JString? string,
    jni$_.JString string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1.reference;
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<AttributeValue>(const $AttributeValue$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }
}

final class $AttributeValue$NullableType
    extends jni$_.JObjType<AttributeValue?> {
  @jni$_.internal
  const $AttributeValue$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/AttributeValue;';

  @jni$_.internal
  @core$_.override
  AttributeValue? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : AttributeValue.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributeValue?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributeValue$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AttributeValue$NullableType) &&
        other is $AttributeValue$NullableType;
  }
}

final class $AttributeValue$Type extends jni$_.JObjType<AttributeValue> {
  @jni$_.internal
  const $AttributeValue$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/AttributeValue;';

  @jni$_.internal
  @core$_.override
  AttributeValue fromReference(jni$_.JReference reference) =>
      AttributeValue.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributeValue?> get nullableType =>
      const $AttributeValue$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributeValue$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AttributeValue$Type) &&
        other is $AttributeValue$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.Entity$Companion`
class Entity$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Entity$Companion> $type;

  @jni$_.internal
  Entity$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/Entity$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Entity$Companion$NullableType();
  static const type = $Entity$Companion$Type();
  static final _id_fromAttributePool = _class.instanceMethodId(
    r'fromAttributePool',
    r'(Ljava/lang/String;Lkotlin/sequences/Sequence;)Lcom/daylightcomputer/coreplugin/entity/Entity;',
  );

  static final _fromAttributePool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.Entity fromAttributePool(java.lang.String string, kotlin.sequences.Sequence sequence)`
  /// The returned object must be released after use, by calling the [release] method.
  Entity fromAttributePool(
    jni$_.JString string,
    jni$_.JObject sequence,
  ) {
    final _$string = string.reference;
    final _$sequence = sequence.reference;
    return _fromAttributePool(
            reference.pointer,
            _id_fromAttributePool as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sequence.pointer)
        .object<Entity>(const $Entity$Type());
  }

  static final _id_fromAttributePool$1 = _class.instanceMethodId(
    r'fromAttributePool',
    r'(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;',
  );

  static final _fromAttributePool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final kotlin.sequences.Sequence fromAttributePool(kotlin.sequences.Sequence sequence)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject fromAttributePool$1(
    jni$_.JObject sequence,
  ) {
    final _$sequence = sequence.reference;
    return _fromAttributePool$1(reference.pointer,
            _id_fromAttributePool$1 as jni$_.JMethodIDPtr, _$sequence.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Entity$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return Entity$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $Entity$Companion$NullableType
    extends jni$_.JObjType<Entity$Companion?> {
  @jni$_.internal
  const $Entity$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/Entity$Companion;';

  @jni$_.internal
  @core$_.override
  Entity$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Entity$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$Companion$NullableType) &&
        other is $Entity$Companion$NullableType;
  }
}

final class $Entity$Companion$Type extends jni$_.JObjType<Entity$Companion> {
  @jni$_.internal
  const $Entity$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/Entity$Companion;';

  @jni$_.internal
  @core$_.override
  Entity$Companion fromReference(jni$_.JReference reference) =>
      Entity$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity$Companion?> get nullableType =>
      const $Entity$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$Companion$Type) &&
        other is $Entity$Companion$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.Entity`
class Entity extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Entity> $type;

  @jni$_.internal
  Entity.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/daylightcomputer/coreplugin/entity/Entity');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Entity$NullableType();
  static const type = $Entity$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/daylightcomputer/coreplugin/entity/Entity$Companion;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.Entity$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static Entity$Companion get Companion =>
      _id_Companion.get(_class, const $Entity$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Entity(
    jni$_.JString string,
    jni$_.JMap<jni$_.JString, AttributeValue> map,
  ) {
    final _$string = string.reference;
    final _$map = map.reference;
    return Entity.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$map.pointer)
        .reference);
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAttributes = _class.instanceMethodId(
    r'getAttributes',
    r'()Ljava/util/Map;',
  );

  static final _getAttributes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map getAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, AttributeValue> getAttributes() {
    return _getAttributes(
            reference.pointer, _id_getAttributes as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, AttributeValue>>(
            const jni$_.JMapType<jni$_.JString, AttributeValue>(
                jni$_.JStringType(), $AttributeValue$Type()));
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/String;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/util/Map;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, AttributeValue> component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, AttributeValue>>(
            const jni$_.JMapType<jni$_.JString, AttributeValue>(
                jni$_.JStringType(), $AttributeValue$Type()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/String;Ljava/util/Map;)Lcom/daylightcomputer/coreplugin/entity/Entity;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.Entity copy(java.lang.String string, java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  Entity copy(
    jni$_.JString string,
    jni$_.JMap<jni$_.JString, AttributeValue> map,
  ) {
    final _$string = string.reference;
    final _$map = map.reference;
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr,
            _$string.pointer, _$map.pointer)
        .object<Entity>(const $Entity$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }
}

final class $Entity$NullableType extends jni$_.JObjType<Entity?> {
  @jni$_.internal
  const $Entity$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/daylightcomputer/coreplugin/entity/Entity;';

  @jni$_.internal
  @core$_.override
  Entity? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Entity.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$NullableType) &&
        other is $Entity$NullableType;
  }
}

final class $Entity$Type extends jni$_.JObjType<Entity> {
  @jni$_.internal
  const $Entity$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/daylightcomputer/coreplugin/entity/Entity;';

  @jni$_.internal
  @core$_.override
  Entity fromReference(jni$_.JReference reference) => Entity.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Entity?> get nullableType => const $Entity$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Entity$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Entity$Type) && other is $Entity$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.node.DocumentNode`
class DocumentNode extends Node {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DocumentNode> $type;

  @jni$_.internal
  DocumentNode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/node/DocumentNode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DocumentNode$NullableType();
  static const type = $DocumentNode$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DocumentNode(
    Entity entity,
  ) {
    final _$entity = entity.reference;
    return DocumentNode.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$entity.pointer)
        .reference);
  }

  static final _id_getTitle = _class.instanceMethodId(
    r'getTitle',
    r'()Ljava/lang/String;',
  );

  static final _getTitle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getTitle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTitle() {
    return _getTitle(reference.pointer, _id_getTitle as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAuthor = _class.instanceMethodId(
    r'getAuthor',
    r'()Ljava/lang/String;',
  );

  static final _getAuthor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getAuthor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAuthor() {
    return _getAuthor(reference.pointer, _id_getAuthor as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $DocumentNode$NullableType extends jni$_.JObjType<DocumentNode?> {
  @jni$_.internal
  const $DocumentNode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/node/DocumentNode;';

  @jni$_.internal
  @core$_.override
  DocumentNode? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : DocumentNode.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Node$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DocumentNode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($DocumentNode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DocumentNode$NullableType) &&
        other is $DocumentNode$NullableType;
  }
}

final class $DocumentNode$Type extends jni$_.JObjType<DocumentNode> {
  @jni$_.internal
  const $DocumentNode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/node/DocumentNode;';

  @jni$_.internal
  @core$_.override
  DocumentNode fromReference(jni$_.JReference reference) =>
      DocumentNode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Node$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DocumentNode?> get nullableType =>
      const $DocumentNode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($DocumentNode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DocumentNode$Type) &&
        other is $DocumentNode$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.node.Node`
class Node extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Node> $type;

  @jni$_.internal
  Node.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/daylightcomputer/coreplugin/entity/node/Node');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Node$NullableType();
  static const type = $Node$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Node(
    Entity entity,
  ) {
    final _$entity = entity.reference;
    return Node.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$entity.pointer)
        .reference);
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.node.NodeTypes getType()`
  /// The returned object must be released after use, by calling the [release] method.
  NodeTypes getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<NodeTypes>(const $NodeTypes$Type());
  }

  static final _id_getLastModifiedAtTimestamp = _class.instanceMethodId(
    r'getLastModifiedAtTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getLastModifiedAtTimestamp =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final java.lang.String getLastModifiedAtTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getLastModifiedAtTimestamp() {
    return _getLastModifiedAtTimestamp(reference.pointer,
            _id_getLastModifiedAtTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_isDeleted = _class.instanceMethodId(
    r'isDeleted',
    r'()Z',
  );

  static final _isDeleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean isDeleted()`
  bool isDeleted() {
    return _isDeleted(reference.pointer, _id_isDeleted as jni$_.JMethodIDPtr)
        .boolean;
  }
}

final class $Node$NullableType extends jni$_.JObjType<Node?> {
  @jni$_.internal
  const $Node$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/daylightcomputer/coreplugin/entity/node/Node;';

  @jni$_.internal
  @core$_.override
  Node? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Node.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Node?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Node$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Node$NullableType) &&
        other is $Node$NullableType;
  }
}

final class $Node$Type extends jni$_.JObjType<Node> {
  @jni$_.internal
  const $Node$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/daylightcomputer/coreplugin/entity/node/Node;';

  @jni$_.internal
  @core$_.override
  Node fromReference(jni$_.JReference reference) => Node.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Node?> get nullableType => const $Node$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Node$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Node$Type) && other is $Node$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.node.NodeTypes$Companion`
class NodeTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NodeTypes$Companion> $type;

  @jni$_.internal
  NodeTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/node/NodeTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NodeTypes$Companion$NullableType();
  static const type = $NodeTypes$Companion$Type();
  static final _id_fromString = _class.instanceMethodId(
    r'fromString',
    r'(Ljava/lang/String;)Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;',
  );

  static final _fromString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.node.NodeTypes fromString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NodeTypes fromString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _fromString(reference.pointer, _id_fromString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<NodeTypes>(const $NodeTypes$Type());
  }

  static final _id_createNodeFromEntity = _class.instanceMethodId(
    r'createNodeFromEntity',
    r'(Lcom/daylightcomputer/coreplugin/entity/Entity;)Lcom/daylightcomputer/coreplugin/entity/node/Node;',
  );

  static final _createNodeFromEntity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.daylightcomputer.coreplugin.entity.node.Node createNodeFromEntity(com.daylightcomputer.coreplugin.entity.Entity entity)`
  /// The returned object must be released after use, by calling the [release] method.
  Node? createNodeFromEntity(
    Entity entity,
  ) {
    final _$entity = entity.reference;
    return _createNodeFromEntity(reference.pointer,
            _id_createNodeFromEntity as jni$_.JMethodIDPtr, _$entity.pointer)
        .object<Node?>(const $Node$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NodeTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NodeTypes$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NodeTypes$Companion$NullableType
    extends jni$_.JObjType<NodeTypes$Companion?> {
  @jni$_.internal
  const $NodeTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NodeTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NodeTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NodeTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NodeTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NodeTypes$Companion$NullableType) &&
        other is $NodeTypes$Companion$NullableType;
  }
}

final class $NodeTypes$Companion$Type
    extends jni$_.JObjType<NodeTypes$Companion> {
  @jni$_.internal
  const $NodeTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NodeTypes$Companion fromReference(jni$_.JReference reference) =>
      NodeTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NodeTypes$Companion?> get nullableType =>
      const $NodeTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NodeTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NodeTypes$Companion$Type) &&
        other is $NodeTypes$Companion$Type;
  }
}

/// from: `com.daylightcomputer.coreplugin.entity.node.NodeTypes`
class NodeTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NodeTypes> $type;

  @jni$_.internal
  NodeTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/daylightcomputer/coreplugin/entity/node/NodeTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NodeTypes$NullableType();
  static const type = $NodeTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes$Companion;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.node.NodeTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NodeTypes$Companion get Companion =>
      _id_Companion.get(_class, const $NodeTypes$Companion$Type());

  static final _id_DOCUMENT = _class.staticFieldId(
    r'DOCUMENT',
    r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.node.NodeTypes DOCUMENT`
  /// The returned object must be released after use, by calling the [release] method.
  static NodeTypes get DOCUMENT =>
      _id_DOCUMENT.get(_class, const $NodeTypes$Type());

  static final _id_FOUNDATION = _class.staticFieldId(
    r'FOUNDATION',
    r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;',
  );

  /// from: `static public final com.daylightcomputer.coreplugin.entity.node.NodeTypes FOUNDATION`
  /// The returned object must be released after use, by calling the [release] method.
  static NodeTypes get FOUNDATION =>
      _id_FOUNDATION.get(_class, const $NodeTypes$Type());

  static final _id_getStringValue = _class.instanceMethodId(
    r'getStringValue',
    r'()Ljava/lang/String;',
  );

  static final _getStringValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getStringValue()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getStringValue() {
    return _getStringValue(
            reference.pointer, _id_getStringValue as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getFactory = _class.instanceMethodId(
    r'getFactory',
    r'()Lkotlin/jvm/functions/Function1;',
  );

  static final _getFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final kotlin.jvm.functions.Function1 getFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFactory() {
    return _getFactory(reference.pointer, _id_getFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.daylightcomputer.coreplugin.entity.node.NodeTypes[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NodeTypes?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<NodeTypes?>?>(
            const jni$_.JArrayNullableType<NodeTypes?>(
                $NodeTypes$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.daylightcomputer.coreplugin.entity.node.NodeTypes valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NodeTypes? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<NodeTypes?>(const $NodeTypes$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $NodeTypes$NullableType extends jni$_.JObjType<NodeTypes?> {
  @jni$_.internal
  const $NodeTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;';

  @jni$_.internal
  @core$_.override
  NodeTypes? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NodeTypes.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NodeTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NodeTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NodeTypes$NullableType) &&
        other is $NodeTypes$NullableType;
  }
}

final class $NodeTypes$Type extends jni$_.JObjType<NodeTypes> {
  @jni$_.internal
  const $NodeTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/daylightcomputer/coreplugin/entity/node/NodeTypes;';

  @jni$_.internal
  @core$_.override
  NodeTypes fromReference(jni$_.JReference reference) =>
      NodeTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NodeTypes?> get nullableType =>
      const $NodeTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NodeTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NodeTypes$Type) && other is $NodeTypes$Type;
  }
}
