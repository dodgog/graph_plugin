package com.daylightcomputer.coreplugin.database.sqldefinitions

import assertk.assertThat
import assertk.assertions.hasSize
import assertk.assertions.isEmpty
import assertk.assertions.isEqualTo
import assertk.assertions.isNotNull
import org.junit.Test

/**
 * AIUSE: generated by AI/
 * Comprehensive test suite for the attributes table covering edge cases,
 * boundary conditions, and robustness scenarios.
 *
 * This complements the basic tests in AttributesTableTests.kt with more
 * extensive coverage of:
 * - Edge cases and boundary conditions
 * - Data integrity scenarios
 * - Performance with larger datasets
 * - Special character and unicode handling
 * - Timestamp ordering edge cases
 */
class AttributesTableStressTests {
    @Test
    fun `cleanAttributesTable should remove all attributes`() =
        testing { db ->
            // Insert some test data
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Title 1",
                timestamp = "1-o-clock",
            )

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node2",
                attr_name = "description",
                attr_val = "Description 2",
                timestamp = "2-o-clock",
            )

            // Verify data exists
            val beforeClean =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(beforeClean).hasSize(2)

            // Clean the table
            db.attributesQueries.cleanAttributesTable()

            // Verify table is empty
            val afterClean =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterClean).isEmpty()
        }

    @Test
    fun `getAttributesForEntity should return empty for nonexistent entity`() =
        testing { db ->
            // Insert attributes for one entity
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "existingNode",
                attr_name = "title",
                attr_val = "Existing Title",
                timestamp = "1-o-clock",
            )

            // Query for different entity should return empty
            val nonExistentResult =
                db.attributesQueries
                    .getAttributesForEntity("nonExistentNode")
                    .executeAsList()
            assertThat(nonExistentResult).isEmpty()

            // Query for existing entity should return data
            val existingResult =
                db.attributesQueries
                    .getAttributesForEntity("existingNode")
                    .executeAsList()
            assertThat(existingResult).hasSize(1)
        }

    @Test
    fun `empty string values should be handled correctly`() =
        testing { db ->
            // Test empty entity_id - should work (TEXT NOT NULL allows empty strings)
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "",
                attr_name = "title",
                attr_val = "Title for empty entity",
                timestamp = "1-o-clock",
            )

            // Test empty attribute name
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "",
                attr_val = "Value for empty attribute",
                timestamp = "1-o-clock",
            )

            // Test empty attr_val
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node2",
                attr_name = "title",
                attr_val = "",
                timestamp = "1-o-clock",
            )

            val allAttributes =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(allAttributes).hasSize(3)

            // Verify empty values are preserved
            val emptyEntityAttr = allAttributes.find { it.entity_id == "" }
            val emptyAttributeAttr = allAttributes.find { it.attr_name == "" }
            val emptyValueAttr = allAttributes.find { it.attr_val == "" }

            assertThat(emptyEntityAttr).isNotNull()
            assertThat(emptyAttributeAttr).isNotNull()
            assertThat(emptyValueAttr).isNotNull()
        }

    @Test
    fun `special characters and unicode should be handled correctly`() =
        testing { db ->
            val specialChars = "!@#$%^&*()[]{}|\\:;\"'<>?,./"
            val unicodeText = "æµ‹è¯• ðŸš€ emojis Î±Î²Î³"

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = specialChars,
                attr_name = "special",
                attr_val = unicodeText,
                timestamp = "1-o-clock",
            )

            val result = db.attributesQueries.getAttributes().executeAsList()
            assertThat(result).hasSize(1)
            assertThat(result.first().entity_id).isEqualTo(specialChars)
            assertThat(result.first().attr_val).isEqualTo(unicodeText)
        }

    @Test
    fun `large attribute values should be handled correctly`() =
        testing { db ->
            val largeValue = "x".repeat(10000) // 10KB string
            val longEntityId = "entity_" + "x".repeat(1000)
            val longAttribute = "attribute_" + "x".repeat(1000)

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = longEntityId,
                attr_name = longAttribute,
                attr_val = largeValue,
                timestamp = "1-o-clock",
            )

            val result = db.attributesQueries.getAttributes().executeAsList()
            assertThat(result).hasSize(1)
            assertThat(result.first().entity_id).isEqualTo(longEntityId)
            assertThat(result.first().attr_name).isEqualTo(longAttribute)
            assertThat(result.first().attr_val).isEqualTo(largeValue)
        }

    @Test
    fun `timestamp lexicographic ordering edge cases`() =
        testing { db ->
            // Test lexicographic vs chronological ordering issues
            val timestamp1 = "2024-01-01T10:00:00Z"
            val timestamp2 = "2024-01-01T09:00:00Z" // Earlier chronologically
            val timestamp3 = "2024-01-02T08:00:00Z" // Later chronologically

            // Insert with middle timestamp
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "First Value",
                timestamp = timestamp1,
            )

            // Insert with lexicographically smaller but chronologically earlier
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Earlier Value",
                timestamp = timestamp2,
            )

            // Should not update because timestamp2 < timestamp1 lexicographically
            val afterSecond =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterSecond).hasSize(1)
            assertThat(afterSecond.first().attr_val).isEqualTo("First Value")

            // Insert with lexicographically and chronologically later
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Later Value",
                timestamp = timestamp3,
            )

            // Should update because timestamp3 > timestamp1 lexicographically
            val afterThird =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterThird).hasSize(1)
            assertThat(afterThird.first().attr_val).isEqualTo("Later Value")
        }

    @Test
    fun `numeric string timestamp ordering`() =
        testing { db ->
            // Test numeric string ordering edge cases
            val timestamp1 = "100"
            val timestamp2 = "99"
            val timestamp3 = "101"

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "First Value",
                timestamp = timestamp1,
            )

            // Should update because "99" > "100" lexicographically
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Second Value",
                timestamp = timestamp2,
            )

            val afterSecond =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterSecond).hasSize(1)
            assertThat(afterSecond.first().attr_val).isEqualTo("Second Value")

            // Should not update because "101" < "99" lexicographically
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Third Value",
                timestamp = timestamp3,
            )

            val afterThird =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterThird).hasSize(1)
            assertThat(afterThird.first().attr_val).isEqualTo("Second Value")
        }

    @Test
    fun `multiple entities with many attributes each`() =
        testing { db ->
            val entities = (1..10).map { "entity_$it" }
            val attributes =
                listOf("title", "description", "type", "status", "priority")

            // Insert multiple attributes for multiple entities
            entities.forEach { entityId ->
                attributes.forEachIndexed { index, attr ->
                    db.attributesQueries.upsertEventIntoAttributes(
                        entity_id = entityId,
                        attr_name = attr,
                        attr_val = "${attr}_value_for_$entityId",
                        timestamp = "${index}_o_clock",
                    )
                }
            }

            // Verify total count
            val allAttributes =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(allAttributes).hasSize(entities.size * attributes.size)

            // Verify each entity has all attributes
            entities.forEach { entityId ->
                val entityAttrs =
                    db.attributesQueries
                        .getAttributesForEntity(entityId)
                        .executeAsList()
                assertThat(entityAttrs).hasSize(attributes.size)

                attributes.forEach { attr ->
                    val found = entityAttrs.find { it.attr_name == attr }
                    assertThat(
                        found?.attr_val,
                    ).isEqualTo("${attr}_value_for_$entityId")
                }
            }
        }

    @Test
    fun `concurrent updates with different timestamps`() =
        testing { db ->
            val baseTimestamp = "abc-o-clock"

            // Simulate rapid updates with incrementing timestamps
            (1..9).forEach { i ->
                db.attributesQueries.upsertEventIntoAttributes(
                    entity_id = "node1",
                    attr_name = "counter",
                    attr_val = "value_$i",
                    // beware of padding: just the strings 10 < 9
                    timestamp = "${baseTimestamp}${i}Z",
                )
            }

            val result = db.attributesQueries.getAttributes().executeAsList()
            assertThat(result).hasSize(1)
            // Should have the last (lexicographically largest) value
            assertThat(result.first().attr_val).isEqualTo("value_9")
            assertThat(result.first().timestamp).isEqualTo("${baseTimestamp}9Z")
        }

    @Test
    fun `upsert preserves all fields correctly`() =
        testing { db ->
            // Insert initial attribute
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "test_entity",
                attr_name = "test_attr",
                attr_val = "old_value",
                timestamp = "2024-01-01T00:00:00Z",
            )

            // Update with newer timestamp
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "test_entity",
                attr_name = "test_attr",
                attr_val = "new_value",
                timestamp = "2024-01-02T00:00:00Z",
            )

            val updated = db.attributesQueries.getAttributes().executeAsList()
            assertThat(updated).hasSize(1)

            val result = updated.first()
            assertThat(result.entity_id).isEqualTo("test_entity")
            assertThat(result.attr_name).isEqualTo("test_attr")
            assertThat(result.attr_val).isEqualTo("new_value")
            assertThat(result.timestamp).isEqualTo("2024-01-02T00:00:00Z")
        }

    @Test
    fun `mixed case and whitespace in identifiers`() =
        testing { db ->
            val entityWithSpaces = "  entity with spaces  "
            val attrWithSpaces = "  attribute with spaces  "
            val valueWithSpaces = "  value with spaces  "

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = entityWithSpaces,
                attr_name = attrWithSpaces,
                attr_val = valueWithSpaces,
                timestamp = "1-o-clock",
            )

            val result = db.attributesQueries.getAttributes().executeAsList()
            assertThat(result).hasSize(1)

            // Verify spaces are preserved exactly
            assertThat(result.first().entity_id).isEqualTo(entityWithSpaces)
            assertThat(result.first().attr_name).isEqualTo(attrWithSpaces)
            assertThat(result.first().attr_val).isEqualTo(valueWithSpaces)
        }

    @Test
    fun `null-like string values should be handled correctly`() =
        testing { db ->
            // Test various "null-like" string values
            val nullLikeValues =
                listOf(
                    "null",
                    "NULL",
                    "Null",
                    "nil",
                    "NIL",
                    "undefined",
                    "UNDEFINED",
                )

            nullLikeValues.forEachIndexed { index, nullLikeValue ->
                db.attributesQueries.upsertEventIntoAttributes(
                    entity_id = "entity_$index",
                    attr_name = "test_attr",
                    attr_val = nullLikeValue,
                    timestamp = "${index}_o_clock",
                )
            }

            val results = db.attributesQueries.getAttributes().executeAsList()
            assertThat(results).hasSize(nullLikeValues.size)

            // Verify all null-like values are preserved as strings
            nullLikeValues.forEachIndexed { index, expectedValue ->
                val found = results.find { it.entity_id == "entity_$index" }
                assertThat(found?.attr_val).isEqualTo(expectedValue)
            }
        }

    @Test
    fun `timestamp with identical prefixes should order correctly`() =
        testing { db ->
            // Test timestamps with identical prefixes that could cause ordering issues
            val timestamp1 = "2024-01-01T00:00:00.000Z"
            val timestamp2 = "2024-01-01T00:00:00.001Z"
            val timestamp3 = "2024-01-01T00:00:00.100Z"

            // Insert in non-lexicographic order
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Value 1",
                timestamp = timestamp2,
            )

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Value 2",
                timestamp = timestamp3,
            )

            // Should update because timestamp3 > timestamp2
            val afterSecond =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterSecond).hasSize(1)
            assertThat(afterSecond.first().attr_val).isEqualTo("Value 2")

            // Insert earlier timestamp - should not update
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Value 0",
                timestamp = timestamp1,
            )

            val afterThird =
                db.attributesQueries
                    .getAttributes()
                    .executeAsList()
            assertThat(afterThird).hasSize(1)
            assertThat(afterThird.first().attr_val).isEqualTo("Value 2")
        }

    @Test
    fun `case sensitivity in entity_id and attribute names`() =
        testing { db ->
            // Test case sensitivity - these should be treated as different entities/attributes
            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "entity_test",
                attr_name = "title",
                attr_val = "lowercase entity, lowercase attr",
                timestamp = "1-o-clock",
            )

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "ENTITY_TEST",
                attr_name = "title",
                attr_val = "uppercase entity, lowercase attr",
                timestamp = "1-o-clock",
            )

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "entity_test",
                attr_name = "TITLE",
                attr_val = "lowercase entity, uppercase attr",
                timestamp = "1-o-clock",
            )

            val results = db.attributesQueries.getAttributes().executeAsList()
            assertThat(results).hasSize(3)

            // Verify case sensitivity is preserved
            val lowercaseEntity =
                results.filter {
                    it.entity_id == "entity_test"
                }
            val uppercaseEntity =
                results.filter {
                    it.entity_id == "ENTITY_TEST"
                }

            assertThat(lowercaseEntity).hasSize(2)
            assertThat(uppercaseEntity).hasSize(1)
        }

    @Test
    fun `extremely long timestamps should be handled correctly`() =
        testing { db ->
            val longTimestamp = "2024-01-01T00:00:00.000Z" + "x".repeat(1000)

            db.attributesQueries.upsertEventIntoAttributes(
                entity_id = "node1",
                attr_name = "title",
                attr_val = "Value with long timestamp",
                timestamp = longTimestamp,
            )

            val result = db.attributesQueries.getAttributes().executeAsList()
            assertThat(result).hasSize(1)
            assertThat(result.first().timestamp).isEqualTo(longTimestamp)
        }

    @Test
    fun `upsert with identical content should not cause issues`() =
        testing { db ->
            val entityId = "test_entity"
            val attrName = "test_attr"
            val value = "test_value"
            val timestamp = "1-o-clock"

            // Insert same data multiple times
            repeat(5) {
                db.attributesQueries.upsertEventIntoAttributes(
                    entity_id = entityId,
                    attr_name = attrName,
                    attr_val = value,
                    timestamp = timestamp,
                )
            }

            val result = db.attributesQueries.getAttributes().executeAsList()
            assertThat(result).hasSize(1)
            assertThat(result.first().attr_val).isEqualTo(value)
        }

    @Test
    fun `interleaved updates for multiple entity-attribute pairs`() =
        testing { db ->
            // Simulate complex update patterns
            val updates =
                listOf(
                    Triple("entity1", "attr1", "2024-01-01T10:00:00Z"),
                    Triple("entity1", "attr2", "2024-01-01T10:00:01Z"),
                    Triple("entity2", "attr1", "2024-01-01T10:00:02Z"),
                    Triple("entity1", "attr1", "2024-01-01T10:00:03Z"),
                    Triple("entity2", "attr2", "2024-01-01T10:00:04Z"),
                    Triple("entity1", "attr2", "2024-01-01T09:00:00Z"),
                )

            updates.forEachIndexed { index, (entityId, attr, timestamp) ->
                db.attributesQueries.upsertEventIntoAttributes(
                    entity_id = entityId,
                    attr_name = attr,
                    attr_val = "value_$index",
                    timestamp = timestamp,
                )
            }

            val results = db.attributesQueries.getAttributes().executeAsList()
            assertThat(results).hasSize(4) // 2 entities x 2 attributes

            // Verify final state
            val entity1Attr1 =
                results.find {
                    it.entity_id == "entity1" &&
                        it.attr_name == "attr1"
                }
            val entity1Attr2 =
                results.find {
                    it.entity_id == "entity1" &&
                        it.attr_name == "attr2"
                }
            val entity2Attr1 =
                results.find {
                    it.entity_id == "entity2" &&
                        it.attr_name == "attr1"
                }
            val entity2Attr2 =
                results.find {
                    it.entity_id == "entity2" &&
                        it.attr_name == "attr2"
                }

            assertThat(entity1Attr1?.attr_val).isEqualTo("value_3")
            assertThat(entity1Attr2?.attr_val).isEqualTo("value_1")
            assertThat(entity2Attr1?.attr_val).isEqualTo("value_2")
            assertThat(entity2Attr2?.attr_val).isEqualTo("value_4")
        }
}
